<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Visualize the colors of an image as a 3D RGB point cloud</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				
				background-color: #333;
				margin: 0px;
				overflow: hidden;
				
				line-height: 20px;
			}
			
			#container
			{
			    z-index: 10;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
			#image_holder
			{
			    float: left;
			    text-align: center;
			}
			#image
			{
			    max-width: 200px;
			    height: auto;
			}
			#img_name
			{
			    max-width: 200px;
			}
			
			.widget
			{
			    clear: both;
			    padding-top: 5px;
			}

			a {

				color: #0080ff;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
		    <div>Visualize the colors of an image as a 3D RGB point cloud.</div>
		    
		    <div id="image_holder">
		        <a id="img_info" href="#" target="_blank">
                    <div id="img_name">image name</div>
                    <img id="image" src="" alt="Visualized image">
                </a>
                <div id="debug"></div>
                <br>
                <input id="upload" type="file">
    		</div>
    		
    		<div class="widget"><label>Rotation has intertia:<input type="checkbox" id="intertia" /></label></div>
    		<!-- <div class="widget"><button id="look_from_white">Look from white</button></div> -->
    		<div><a href="#" id="look_from_white">Look from white</a></div>
    		<div id="saveScreenshot"><a href="#" onclick="saveScreenshot()">Save PNG</a></div>
    	</div>

		<script src="js/three.min.js"></script>

        <script src="js/controls/TrackballControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/purl.js"></script>
		
		<!--
		<script src="js/Blob.js"></script>
		<script src="js/FileSaver.js"></script>
		-->

		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, controls;

			var particleSystem;
			var img;
			
			var overlayMeshVertices, overlayMeshEdges;
			
			// True by default
			// var kScreenshots = true;
			// unless a `screenshots` parameter is passed with the value 'no'.
			// if( purl().param('screenshots') === 'no' ) kScreenshots = false;
			var kScreenshots = purl().param('screenshots') !== undefined;
			// Hide the Save PNG button if screenshots is not present.
			if( !kScreenshots ) {
	    		var saveScreenshotButton = document.getElementById( 'saveScreenshot' )
    			saveScreenshotButton.parentNode.removeChild( saveScreenshotButton );
    		}
			console.log( "purl 'screenshots': " + purl().param('screenshots') );
            console.log( "kScreenshots: " + kScreenshots );
			
            init3D();
            if( purl().param('image') !== undefined )
            {
                loadImage( decodeURI( purl().param('image') ) );
            }
            else
            {
                loadImage( 'pigs.jpg' );
            }
            
            function loadImage( url, name )
            {
                // The 'name' parameter is optional and defaults to 'url'.
                if( name === undefined ) name = url;
                
                document.getElementById('img_info').href = url;
                document.getElementById('img_name').innerHTML = name;
                /*
                if( url.length > 255 ) {
                    // TODO: Just use overflow: scroll and put the whole thing there.
                    document.getElementById('img_name').innerHTML = '...' + url.substr( -255, 255 );
                } else {
                    document.getElementById('img_name').innerHTML = url;
                }
                */
                
                img = document.getElementById('image');
                // Set the crossOrigin property.
                // From: http://stackoverflow.com/questions/19869150/html5-canvas-element-getimagedata-cross-origin-error
                // From: https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes
                // UPDATE: We do this in the HTML itself, so we don't need this here.
                // UPDATE 2: Setting the cross-origin policy causes this to break on Safari.
                // img.crossOrigin = '';
                // img.crossOrigin = 'anonymous';
                // img.crossOrigin = 'use-credentials';
                
                // Wait until loaded.
                // From: http://stackoverflow.com/questions/280049/javascript-callback-for-knowing-when-an-image-is-loaded/24201249#24201249
                // UPDATE: img.complete returns true for Firefox before the image is actually complete.
                img.onload = createParticles;
                img.onerror = function() { alert( 'Error loading image.' ); console.error( 'Error loading image:' ); console.error( url ) };
                
                img.src = url;
            }
            function uploadImageFile()
            {
                // From: http://stackoverflow.com/questions/22087076/how-to-make-a-simple-image-upload-using-javascript-html
                file = document.getElementById('upload').files[0];
                
                loadFile( file );
            }
            function loadFile( file )
            {
                if( !file ) {
                    alert( 'Failed to load file.' );
                    return;
                }
                
                var reader = new FileReader();
                
                // If it ends with JSON, treat it as a JSON file
                // containing the faces and vertices of the overlay mesh.
                if( /.js(on)?$/.test( file.name ) ) {
                    reader.onload = function() { loadOverlayMesh( JSON.parse( reader.result ) ); };
                    // read the data as a binary string.
                    reader.readAsBinaryString( file );
                }
                else {
                    reader.onload = function() { loadImage( reader.result, file.name ); };
                    // reads the data as a data URL
                    reader.readAsDataURL( file );
                }
            }
            document.getElementById('upload').onchange = uploadImageFile;
            // Drag-and-drop anywhere onto the window.
            // From: http://stackoverflow.com/questions/11124630/how-to-do-document-ondrop-in-firefox
            document.ondragover = function( event ) { event.preventDefault(); }
            document.ondrop = function( event ) { event.preventDefault(); loadFile( event.dataTransfer.files[0] ); }
            
            function saveScreenshot()
            {
                if( !kScreenshots )
                {
                    console.log( "This probably won't work. Refresh the page with ?screenshots" );
                }
                
                var kMIMEType = "image/png";
                var dataURL = renderer.domElement.toDataURL( kMIMEType );
                
                // Open in a new window.
                window.open( dataURL );
                
                /*
                // Save to disk.
                // From: http://stackoverflow.com/questions/17332071/trying-to-save-canvas-png-data-url-to-disk-with-html5-filesystem-but-when-i-ret
                var data = atob( dataURL.replace(/^.*?base64,/, '') );
                var asArray = new Uint8Array( data.length );
                for( var i = 0, len = data.length; i < len; ++i ) {
                    asArray[i] = data.charCodeAt(i);    
                }
                
                // This uses Blob and FileSaver.
                // For old browsers, use:
                // https://github.com/eligrey/Blob.js
                // https://github.com/eligrey/FileSaver.js/
                var blob = new Blob( [ asArray.buffer ], { type: kMIMEType } );
                saveAs( blob, "canvas.png" );
                */
            }
            
            function uniquePixels( data, skip_transparent )
            {
                if( skip_transparent === undefined ) skip_transparent = true;
                /*
                console.log( "skip_transparent:", skip_transparent );
                var skip_count = 0;
                var skipped = {};
                */
                
                /*
                Given an array of RGBA unsigned char values, every four of which represent
                the next pixel, returns an array of unique values.
                */
                
                var unique = {};
                
                var num_pixels = data.length/4;
                for( var i = 0; i < num_pixels; ++i )
                {
                    // Skip transparent pixels
                    if( skip_transparent && data[ 4*i + 3 ] == 0 )
                    {
                        /*
                        skip_count += 1;
                        skipped[ [
                            data[ 4*i + 0 ],
                            data[ 4*i + 1 ],
                            data[ 4*i + 2 ],
                            data[ 4*i + 3 ]
                            ] ] = true;
                        */
                        continue;
                    }
                    
                    unique[ [
                        data[ 4*i + 0 ],
                        data[ 4*i + 1 ],
                        data[ 4*i + 2 ],
                        data[ 4*i + 3 ]
                        ] ] = true;
                }
                
                /*
                /// Chrome reads the RGB channels of 100% transparent pixels as 0,0,0.
                /// I didn't test other browsers.
                console.log( "Number of skipped transparent pixels:", skip_count );
                console.log( skipped );
                */
                
                var result = [];
                
                for( var k in unique )
                {
                    var color = JSON.parse('[' + k + ']');
                    
                    result.push.apply( result, color );
                }
                
                console.log( result.length/4 + " / " + data.length/4 + " = " + (100*result.length/data.length) + "% unique pixels" );
                
                return result;
            }
            
			function createParticles()
            {
                if( particleSystem !== undefined ) scene.remove( particleSystem );
                // Also clear the overlay mesh if there is one.
                clearOverlayMesh();
                
				// Get the particles from the image's pixels.
				// From: http://stackoverflow.com/questions/1041399/how-to-use-javascript-or-jquery-to-read-a-pixel-of-an-image
				var canvas = document.createElement('canvas');
				canvas.width = img.naturalWidth;
				canvas.height = img.naturalHeight;
				var ctx = canvas.getContext("2d");
				ctx.drawImage( img, 0, 0, img.naturalWidth, img.naturalHeight );
				// getImageData returns an RGBA byte array.
				var pixels = uniquePixels( ctx.getImageData( 0, 0, canvas.width, canvas.height ).data );
                
				var particles = pixels.length / 4;

				var geometry = new THREE.BufferGeometry();

				var positions = new Float32Array( particles * 3 );
				var colors = new Float32Array( particles * 3 );

				var color = new THREE.Color();

				for ( var i = 0; i < particles; i += 1 ) {

					// colors

					var r = pixels[ 4*i + 0 ]/255.;
					var g = pixels[ 4*i + 1 ]/255.;
					var b = pixels[ 4*i + 2 ]/255.;
					
					positions[ 3*i + 0 ] = r;
					positions[ 3*i + 1 ] = g;
					positions[ 3*i + 2 ] = b;

					color.setRGB( r, g, b );

					colors[ 3*i + 0 ] = color.r;
					colors[ 3*i + 1 ] = color.g;
					colors[ 3*i + 2 ] = color.b;

				}
				
				document.getElementById('debug').innerHTML =
				    'width: ' + img.naturalWidth + ', height: ' + img.naturalHeight
				    +
				    '<br>total pixels: ' + canvas.width*canvas.height
				    +
				    '<br>unique pixels: ' + particles
				    ;

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

				geometry.computeBoundingSphere();

				//

				var material = new THREE.PointCloudMaterial( { size: 4/255., vertexColors: THREE.VertexColors } );

				particleSystem = new THREE.PointCloud( geometry, material );
				// return particleSystem;
				scene.add( particleSystem );
				
				render();
			}
			
            function createAxisLine( position0, position1, color0, color1, dashed ) {
                // From: http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                var geom = new THREE.Geometry();
                var mat;
                
                if( dashed ) {
                    mat = new THREE.LineDashedMaterial({ linewidth: 1, color: 0xffffff, vertexColors: THREE.VertexColors, dashSize: 10/255., gapSize: 5/255. });
                } else {
                    mat = new THREE.LineBasicMaterial({ linewidth: 2, color: 0xffffff, vertexColors: THREE.VertexColors });
                }
                
                // Lines blend colors.
                // From: http://threejs.org/examples/webgl_lines_colors.html
                geom.colors = [ color0.clone(), color1.clone() ];
                
                geom.vertices.push( position0.clone() );
                geom.vertices.push( position1.clone() );
                geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines
                
                var axis = new THREE.Line( geom, mat, THREE.LinePieces );
                
                return axis;
            }
			function buildAxes( length )
			{
			    // From: http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
                var axes = new THREE.Object3D();
                axes.add( createAxisLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), new THREE.Color( 0x000000 ), new THREE.Color( 0xFF0000 ), false ) ); // +X
                // axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
                axes.add( createAxisLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), new THREE.Color( 0x000000 ), new THREE.Color( 0x00FF00 ), false ) ); // +Y
                // axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
                axes.add( createAxisLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), new THREE.Color( 0x000000 ), new THREE.Color( 0x0000FF ), false ) ); // +Z
                // axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
                
                // XY
                axes.add( createAxisLine( new THREE.Vector3( length, 0, 0 ), new THREE.Vector3( length, length, 0 ), new THREE.Color( 0xFF0000 ), new THREE.Color( 0xFFFF00 ), false ) );
                axes.add( createAxisLine( new THREE.Vector3( 0, length, 0 ), new THREE.Vector3( length, length, 0 ), new THREE.Color( 0x00FF00 ), new THREE.Color( 0xFFFF00 ), false ) );
                
                // YZ
                axes.add( createAxisLine( new THREE.Vector3( 0, length, 0 ), new THREE.Vector3( 0, length, length ), new THREE.Color( 0x00FF00 ), new THREE.Color( 0x00FFFF ), false ) );
                axes.add( createAxisLine( new THREE.Vector3( 0, 0, length ), new THREE.Vector3( 0, length, length ), new THREE.Color( 0x0000FF ), new THREE.Color( 0x00FFFF ), false ) );
                
                // XZ
                axes.add( createAxisLine( new THREE.Vector3( length, 0, 0 ), new THREE.Vector3( length, 0, length ), new THREE.Color( 0xFF0000 ), new THREE.Color( 0xFF00FF ), false ) );
                axes.add( createAxisLine( new THREE.Vector3( 0, 0, length ), new THREE.Vector3( length, 0, length ), new THREE.Color( 0x0000FF ), new THREE.Color( 0xFF00FF ), false ) );
                
                // XY from 1,1,1
                axes.add( createAxisLine( new THREE.Vector3( length, length, length ), new THREE.Vector3( length, length, 0 ), new THREE.Color( 0xFFFFFF ), new THREE.Color( 0xFFFF00 ), false ) );
                
                // YZ from 1,1,1
                axes.add( createAxisLine( new THREE.Vector3( length, length, length ), new THREE.Vector3( 0, length, length ), new THREE.Color( 0xFFFFFF ), new THREE.Color( 0x00FFFF ), false ) );
                
                // XZ from 1,1,1
                axes.add( createAxisLine( new THREE.Vector3( length, length, length ), new THREE.Vector3( length, 0, length ), new THREE.Color( 0xFFFFFF ), new THREE.Color( 0xFF00FF ), false ) );
                
                return axes;
			}
			
			function clearOverlayMesh()
			{
			    if( overlayMeshEdges !== undefined ) scene.remove( overlayMeshEdges );
			    if( overlayMeshVertices !== undefined ) scene.remove( overlayMeshVertices );
			}
			function loadOverlayMesh( hull )
			{
			    console.log( "loadOverlayMesh( ... ):" );
			    console.log( hull );
			    
			    clearOverlayMesh();
			    
                /// Create the overlayMeshEdges
                if( hull.faces !== undefined && hull.faces.length > 0 ) {
                    var geometry = new THREE.Geometry();
                    
                    /// "Smart" faces which are indices into vertices.
                    /*
                    // Copy vertices
                    for( var i = 0; i < hull.vs.length; ++i ) {
                        var vert = hull.vs[i];
                        geometry.vertices.push( new THREE.Vector3( vert[0]/255., vert[1]/255., vert[2]/255. ) );
                    }
                    // Copy faces
                    for( var i = 0; i < hull.faces.length; ++i ) {
                        var face = hull.faces[i];
                        geometry.faces.push( new THREE.Face3( face[0], face[1], face[2] ) );
                    }
                    */
                    
                    
                    /// "Dumb" faces which are each a triplet of positions.
                    for( var i = 0; i < hull.faces.length; ++i ) {
                        var face = hull.faces[i];
                        
                        var n = geometry.vertices.length;
                        geometry.faces.push( new THREE.Face3( n+0, n+1, n+2 ) );
                        
                        for( var fi = 0; fi < 3; ++fi )
                        {
                            var vert = face[fi];
                            geometry.vertices.push( new THREE.Vector3( vert[0]/255., vert[1]/255., vert[2]/255. ) );
                        }
                    }
                    
                    geometry.verticesNeedUpdate = true;
                    geometry.elementsNeedUpdate = true;
                    
                    var edge_material = new THREE.MeshBasicMaterial({
                        color: 0xFFFFFF,
                        wireframe: true,
                        wireframeLinewidth: 10
                        });
                    
                    overlayMeshEdges = new THREE.Mesh( geometry, edge_material );
                    scene.add( overlayMeshEdges );
				}
				
				
				/// Create the overlayMeshVertices
				if( hull.vs.length > 0 ) {
                    overlayMeshVertices = new THREE.Object3D();
                    // Create a circle for each vertex
                    for( var i = 0; i < hull.vs.length; ++i ) {
                        var vert = hull.vs[i];
                        var circleMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color( vert[0]/255., vert[1]/255., vert[2]/255. )
                            });
                        
                        var radius = 5./255;
                        var segments = 32;
                        var circleGeometry = new THREE.SphereGeometry( radius, segments, segments );
                        var circle = new THREE.Mesh( circleGeometry, circleMaterial );
                        circle.position.set( vert[0]/255., vert[1]/255., vert[2]/255. );
                        
                        overlayMeshVertices.add( circle );
                        
                        
                        // HACK: A white rim.
                        circleGeometry = new THREE.CircleGeometry( radius*1.2, segments );
                        circle = new THREE.Mesh( circleGeometry, new THREE.MeshBasicMaterial({ color: 0xFFFFFF }) );
                        circle.position.set( vert[0]/255., vert[1]/255., vert[2]/255. );
                        
                        overlayMeshVertices.add( circle );
                    }
                    scene.add( overlayMeshVertices );
				}
				
				
				render();
			}
			
			function initControls( camera ) {
			    controls = new THREE.TrackballControls( camera );
			    controls.target.set( .5, .5, .5 );
			    
			    controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = true;
				controls.noPan = true;
				// Keep the horizon level? No.
				camera.noRoll = false;

				controls.staticMoving = true;
				// dynamicDampingFactor only has an effect when staticMoving is false.
				// Setting it to 0 allows constant-speed rotation in a loop.
				controls.dynamicDampingFactor = 0.0;

				controls.addEventListener( 'change', render );

				// Set up the inertial rotation checkbox.
				document.getElementById( 'intertia' ).addEventListener( 'change', function() { controls.staticMoving = !document.getElementById('intertia').checked; } );
				document.getElementById( 'intertia' ).checked = !controls.staticMoving;
				
				document.getElementById( 'look_from_white' ).addEventListener( 'click', function() {
				    // First reset the controls
				    controls.reset();
				    controls.target.set( .5, .5, .5 );
				    
				    var targetToCameraLength = camera.position.clone().sub( controls.target ).length();
				    
				    camera.position.set( 1, 1, 1 );
				    camera.position.sub( controls.target ).setLength( targetToCameraLength ).add( controls.target );
				    } );
			}
			
			function init3D() {

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10 );
				camera.position.set( .5, .5, 3 );
				camera.lookAt( new THREE.Vector3( .5, .5, .5 ) );
				// camera = new THREE.OrthographicCamera( -1, 2, 2, -1, 1, 4 );
				// camera.position.z = 4;

				scene = new THREE.Scene();
				// scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );
                
                //
                
                // scene.add( createParticles() );
				scene.add( buildAxes( 1. ) );
                
				//

				renderer = new THREE.WebGLRenderer( {
				    antialias: true,
				    // This is necessary for saving screenshots with .toDataURL("image/png")
				    preserveDrawingBuffer: kScreenshots // true
				    } );
				// renderer.setClearColor( scene.fog.color );
				renderer.setClearColor( new THREE.Color( '#888888' ) );
				// I tried setting this to 3., and the canvas appears stretched.
				renderer.setPixelRatio( kScreenshots ? 2. : window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.right = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
                
                initControls( camera );
                
                // Start drawing
                animate();
                render();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
                
                controls.handleResize();
                
                render();
			}

			//

			function animate() {
				requestAnimationFrame( animate );
                controls.update();
                // If we have dynamic movement, we need to call render every frame.
                if( !controls.staticMoving ) render();
			}

			function render() {
			    // HACK: Update overlay mesh vertices' white rims.
			    if( overlayMeshVertices !== undefined ) {
			        for( var i = 1; i < overlayMeshVertices.children.length; i += 2 )
			        {
			            overlayMeshVertices.children[i].lookAt( camera.position );
			        }
			    }
			    
				renderer.render( scene, camera );
                stats.update();
			}
		</script>

	</body>
</html>
